/*! For license information please see 618.plugin.js.LICENSE.txt */
"use strict";exports.id=618,exports.ids=[618],exports.modules={55458:(e,t,a)=>{a.d(t,{E:()=>s});var r=a(60053),n=a(32385);class i{}class s extends i{get lc_namespace(){return["langchain","callbacks",this.name]}get lc_secrets(){}get lc_attributes(){}get lc_aliases(){}static lc_name(){return this.name}get lc_id(){return[...this.lc_namespace,(0,n.j)(this.constructor)]}constructor(e){super(),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"lc_kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"ignoreLLM",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreChain",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreAgent",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreRetriever",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"awaitHandlers",{enumerable:!0,configurable:!0,writable:!0,value:"undefined"==typeof process||"true"!==process.env?.LANGCHAIN_CALLBACKS_BACKGROUND}),this.lc_kwargs=e||{},e&&(this.ignoreLLM=e.ignoreLLM??this.ignoreLLM,this.ignoreChain=e.ignoreChain??this.ignoreChain,this.ignoreAgent=e.ignoreAgent??this.ignoreAgent,this.ignoreRetriever=e.ignoreRetriever??this.ignoreRetriever)}copy(){return new this.constructor(this)}toJSON(){return n.i.prototype.toJSON.call(this)}toJSONNotImplemented(){return n.i.prototype.toJSONNotImplemented.call(this)}static fromMethods(e){return new class extends s{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:r.Z()}),Object.assign(this,e)}}}}},13803:(e,t,a)=>{a.d(t,{Z:()=>i});var r=a(55458);function n(e,t){return e&&!Array.isArray(e)&&"object"==typeof e?e:{[t]:e}}class i extends r.E{constructor(e){super(...arguments),Object.defineProperty(this,"runMap",{enumerable:!0,configurable:!0,writable:!0,value:new Map})}copy(){return this}_addChildRun(e,t){e.child_runs.push(t)}async _startTrace(e){if(void 0!==e.parent_run_id){const t=this.runMap.get(e.parent_run_id);t&&(this._addChildRun(t,e),t.child_execution_order=Math.max(t.child_execution_order,e.child_execution_order))}this.runMap.set(e.id,e),await(this.onRunCreate?.(e))}async _endTrace(e){const t=void 0!==e.parent_run_id&&this.runMap.get(e.parent_run_id);t?t.child_execution_order=Math.max(t.child_execution_order,e.child_execution_order):await this.persistRun(e),this.runMap.delete(e.id),await(this.onRunUpdate?.(e))}_getExecutionOrder(e){const t=void 0!==e&&this.runMap.get(e);return t?t.child_execution_order+1:1}async handleLLMStart(e,t,a,r,n,i,s,o){const l=this._getExecutionOrder(r),c=Date.now(),d=s?{...n,metadata:s}:n,u={id:a,name:o??e.id[e.id.length-1],parent_run_id:r,start_time:c,serialized:e,events:[{name:"start",time:new Date(c).toISOString()}],inputs:{prompts:t},execution_order:l,child_runs:[],child_execution_order:l,run_type:"llm",extra:d??{},tags:i||[]};return await this._startTrace(u),await(this.onLLMStart?.(u)),u}async handleChatModelStart(e,t,a,r,n,i,s,o){const l=this._getExecutionOrder(r),c=Date.now(),d=s?{...n,metadata:s}:n,u={id:a,name:o??e.id[e.id.length-1],parent_run_id:r,start_time:c,serialized:e,events:[{name:"start",time:new Date(c).toISOString()}],inputs:{messages:t},execution_order:l,child_runs:[],child_execution_order:l,run_type:"llm",extra:d??{},tags:i||[]};return await this._startTrace(u),await(this.onLLMStart?.(u)),u}async handleLLMEnd(e,t){const a=this.runMap.get(t);if(!a||"llm"!==a?.run_type)throw new Error("No LLM run to end.");return a.end_time=Date.now(),a.outputs=e,a.events.push({name:"end",time:new Date(a.end_time).toISOString()}),await(this.onLLMEnd?.(a)),await this._endTrace(a),a}async handleLLMError(e,t){const a=this.runMap.get(t);if(!a||"llm"!==a?.run_type)throw new Error("No LLM run to end.");return a.end_time=Date.now(),a.error=e.message,a.events.push({name:"error",time:new Date(a.end_time).toISOString()}),await(this.onLLMError?.(a)),await this._endTrace(a),a}async handleChainStart(e,t,a,r,n,i,s,o){const l=this._getExecutionOrder(r),c=Date.now(),d={id:a,name:o??e.id[e.id.length-1],parent_run_id:r,start_time:c,serialized:e,events:[{name:"start",time:new Date(c).toISOString()}],inputs:t,execution_order:l,child_execution_order:l,run_type:s??"chain",child_runs:[],extra:i?{metadata:i}:{},tags:n||[]};return await this._startTrace(d),await(this.onChainStart?.(d)),d}async handleChainEnd(e,t,a,r,i){const s=this.runMap.get(t);if(!s)throw new Error("No chain run to end.");return s.end_time=Date.now(),s.outputs=n(e,"output"),s.events.push({name:"end",time:new Date(s.end_time).toISOString()}),void 0!==i?.inputs&&(s.inputs=n(i.inputs,"input")),await(this.onChainEnd?.(s)),await this._endTrace(s),s}async handleChainError(e,t,a,r,i){const s=this.runMap.get(t);if(!s)throw new Error("No chain run to end.");return s.end_time=Date.now(),s.error=e.message,s.events.push({name:"error",time:new Date(s.end_time).toISOString()}),void 0!==i?.inputs&&(s.inputs=n(i.inputs,"input")),await(this.onChainError?.(s)),await this._endTrace(s),s}async handleToolStart(e,t,a,r,n,i,s){const o=this._getExecutionOrder(r),l=Date.now(),c={id:a,name:s??e.id[e.id.length-1],parent_run_id:r,start_time:l,serialized:e,events:[{name:"start",time:new Date(l).toISOString()}],inputs:{input:t},execution_order:o,child_execution_order:o,run_type:"tool",child_runs:[],extra:i?{metadata:i}:{},tags:n||[]};return await this._startTrace(c),await(this.onToolStart?.(c)),c}async handleToolEnd(e,t){const a=this.runMap.get(t);if(!a||"tool"!==a?.run_type)throw new Error("No tool run to end");return a.end_time=Date.now(),a.outputs={output:e},a.events.push({name:"end",time:new Date(a.end_time).toISOString()}),await(this.onToolEnd?.(a)),await this._endTrace(a),a}async handleToolError(e,t){const a=this.runMap.get(t);if(!a||"tool"!==a?.run_type)throw new Error("No tool run to end");return a.end_time=Date.now(),a.error=e.message,a.events.push({name:"error",time:new Date(a.end_time).toISOString()}),await(this.onToolError?.(a)),await this._endTrace(a),a}async handleAgentAction(e,t){const a=this.runMap.get(t);if(!a||"chain"!==a?.run_type)return;const r=a;r.actions=r.actions||[],r.actions.push(e),r.events.push({name:"agent_action",time:(new Date).toISOString(),kwargs:{action:e}}),await(this.onAgentAction?.(a))}async handleAgentEnd(e,t){const a=this.runMap.get(t);a&&"chain"===a?.run_type&&(a.events.push({name:"agent_end",time:(new Date).toISOString(),kwargs:{action:e}}),await(this.onAgentEnd?.(a)))}async handleRetrieverStart(e,t,a,r,n,i,s){const o=this._getExecutionOrder(r),l=Date.now(),c={id:a,name:s??e.id[e.id.length-1],parent_run_id:r,start_time:l,serialized:e,events:[{name:"start",time:new Date(l).toISOString()}],inputs:{query:t},execution_order:o,child_execution_order:o,run_type:"retriever",child_runs:[],extra:i?{metadata:i}:{},tags:n||[]};return await this._startTrace(c),await(this.onRetrieverStart?.(c)),c}async handleRetrieverEnd(e,t){const a=this.runMap.get(t);if(!a||"retriever"!==a?.run_type)throw new Error("No retriever run to end");return a.end_time=Date.now(),a.outputs={documents:e},a.events.push({name:"end",time:new Date(a.end_time).toISOString()}),await(this.onRetrieverEnd?.(a)),await this._endTrace(a),a}async handleRetrieverError(e,t){const a=this.runMap.get(t);if(!a||"retriever"!==a?.run_type)throw new Error("No retriever run to end");return a.end_time=Date.now(),a.error=e.message,a.events.push({name:"error",time:new Date(a.end_time).toISOString()}),await(this.onRetrieverError?.(a)),await this._endTrace(a),a}async handleText(e,t){const a=this.runMap.get(t);a&&"chain"===a?.run_type&&(a.events.push({name:"text",time:(new Date).toISOString(),kwargs:{text:e}}),await(this.onText?.(a)))}async handleLLMNewToken(e,t,a,r,n,i){const s=this.runMap.get(a);if(!s||"llm"!==s?.run_type)throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');return s.events.push({name:"new_token",time:(new Date).toISOString(),kwargs:{token:e,idx:t,chunk:i?.chunk}}),await(this.onLLMNewToken?.(s,e)),s}}},49354:(e,t,a)=>{a.d(t,{Ye:()=>J});var r=a(60053),n=a(55458),i=a(26434),s=a(13803);function o(e,t){return`${e.open}${t}${e.close}`}function l(e,t){try{return JSON.stringify(e,null,2)}catch(e){return t}}function c(e){if(!e.end_time)return"";const t=e.end_time-e.start_time;return t<1e3?`${t}ms`:`${(t/1e3).toFixed(2)}s`}const{color:d}=i;class u extends s.Z{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"console_callback_handler"})}persistRun(e){return Promise.resolve()}getParents(e){const t=[];let a=e;for(;a.parent_run_id;){const e=this.runMap.get(a.parent_run_id);if(!e)break;t.push(e),a=e}return t}getBreadcrumbs(e){const t=[...this.getParents(e).reverse(),e].map(((e,t,a)=>{const r=`${e.execution_order}:${e.run_type}:${e.name}`;return t===a.length-1?o(i.bold,r):r})).join(" > ");return o(d.grey,t)}onChainStart(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.green,"[chain/start]")} [${t}] Entering Chain run with input: ${l(e.inputs,"[inputs]")}`)}onChainEnd(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.cyan,"[chain/end]")} [${t}] [${c(e)}] Exiting Chain run with output: ${l(e.outputs,"[outputs]")}`)}onChainError(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.red,"[chain/error]")} [${t}] [${c(e)}] Chain run errored with error: ${l(e.error,"[error]")}`)}onLLMStart(e){const t=this.getBreadcrumbs(e),a="prompts"in e.inputs?{prompts:e.inputs.prompts.map((e=>e.trim()))}:e.inputs;console.log(`${o(d.green,"[llm/start]")} [${t}] Entering LLM run with input: ${l(a,"[inputs]")}`)}onLLMEnd(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.cyan,"[llm/end]")} [${t}] [${c(e)}] Exiting LLM run with output: ${l(e.outputs,"[response]")}`)}onLLMError(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.red,"[llm/error]")} [${t}] [${c(e)}] LLM run errored with error: ${l(e.error,"[error]")}`)}onToolStart(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.green,"[tool/start]")} [${t}] Entering Tool run with input: "${e.inputs.input?.trim()}"`)}onToolEnd(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.cyan,"[tool/end]")} [${t}] [${c(e)}] Exiting Tool run with output: "${e.outputs?.output?.trim()}"`)}onToolError(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.red,"[tool/error]")} [${t}] [${c(e)}] Tool run errored with error: ${l(e.error,"[error]")}`)}onRetrieverStart(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.green,"[retriever/start]")} [${t}] Entering Retriever run with input: ${l(e.inputs,"[inputs]")}`)}onRetrieverEnd(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.cyan,"[retriever/end]")} [${t}] [${c(e)}] Exiting Retriever run with output: ${l(e.outputs,"[outputs]")}`)}onRetrieverError(e){const t=this.getBreadcrumbs(e);console.log(`${o(d.red,"[retriever/error]")} [${t}] [${c(e)}] Retriever run errored with error: ${l(e.error,"[error]")}`)}onAgentAction(e){const t=e,a=this.getBreadcrumbs(e);console.log(`${o(d.blue,"[agent/action]")} [${a}] Agent selected action: ${l(t.actions[t.actions.length-1],"[action]")}`)}}var h=a(80359),p=a(42693),m=a(45860);const f=[400,401,403,404,405,406,407,408,409];class w{constructor(e){Object.defineProperty(this,"maxConcurrency",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxRetries",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxConcurrency=e.maxConcurrency??1/0,this.maxRetries=e.maxRetries??6;const t=m.default;this.queue=new t({concurrency:this.maxConcurrency})}call(e,...t){return this.queue.add((()=>p((()=>e(...t).catch((e=>{throw e instanceof Error?e:new Error(e)}))),{onFailedAttempt(e){if(e.message.startsWith("Cancel")||e.message.startsWith("TimeoutError")||e.message.startsWith("AbortError"))throw e;if("ECONNABORTED"===e?.code)throw e;const t=e?.response?.status;if(t&&f.includes(+t))throw e},retries:this.maxRetries,randomize:!0})),{throwOnTimeout:!0})}callWithOptions(e,t,...a){return e.signal?Promise.race([this.call(t,...a),new Promise(((t,a)=>{e.signal?.addEventListener("abort",(()=>{a(new Error("AbortError"))}))}))]):this.call(t,...a)}fetch(...e){return this.call((()=>fetch(...e).then((e=>e.ok?e:Promise.reject(e)))))}}function g(e){return"function"==typeof e?._getType}function b(e){const t={type:e._getType(),data:{content:e.content}};return e?.additional_kwargs&&Object.keys(e.additional_kwargs).length>0&&(t.data.additional_kwargs={...e.additional_kwargs}),t}const y=()=>"undefined"!=typeof Deno;let _,v;async function E(){if(void 0===_){const e=(()=>{let e;return e="undefined"!=typeof window&&void 0!==window.document?"browser":"undefined"==typeof process||void 0===process.versions||void 0===process.versions.node||y()?"object"==typeof globalThis&&globalThis.constructor&&"DedicatedWorkerGlobalScope"===globalThis.constructor.name?"webworker":"undefined"!=typeof window&&"nodejs"===window.name||"undefined"!=typeof navigator&&(navigator.userAgent.includes("Node.js")||navigator.userAgent.includes("jsdom"))?"jsdom":y()?"deno":"other":"node",e})(),t=function(){if(void 0!==v)return v;const e=["VERCEL_GIT_COMMIT_SHA","NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA","COMMIT_REF","RENDER_GIT_COMMIT","CI_COMMIT_SHA","CIRCLE_SHA1","CF_PAGES_COMMIT_SHA","REACT_APP_GIT_SHA","SOURCE_VERSION","GITHUB_SHA","TRAVIS_COMMIT","GIT_COMMIT","BUILD_VCS_NUMBER","bamboo_planRepository_revision","Build.SourceVersion","BITBUCKET_COMMIT","DRONE_COMMIT_SHA","SEMAPHORE_GIT_SHA","BUILDKITE_COMMIT"],t={};for(const a of e){const e=O(a);void 0!==e&&(t[a]=e)}return v=t,t}();_={library:"langsmith",runtime:e,...t}}return _}function O(e){try{return"undefined"!=typeof process?process.env?.[e]:void 0}catch(e){return}}const T=e=>{const t=e.replace("http://","").replace("https://","").split("/")[0].split(":")[0];return"localhost"===t||"127.0.0.1"===t||"::1"===t},S=async(e,t)=>{const a=await e.text();if(!e.ok)throw new Error(`Failed to ${t}: ${e.status} ${e.statusText} ${a}`)};function P(e){if(void 0!==e)return e.trim().replace(/^"(.*)"$/,"$1").replace(/^'(.*)'$/,"$1")}function A(e){return"true"===O("LANGCHAIN_HIDE_INPUTS")?{}:e}function j(e){return"true"===O("LANGCHAIN_HIDE_OUTPUTS")?{}:e}function I(e){if(!h.Z(e))throw new Error(`Invalid UUID: ${e}`)}class x{constructor(e={}){Object.defineProperty(this,"apiKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"apiUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"webUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"caller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"timeout_ms",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_tenantId",{enumerable:!0,configurable:!0,writable:!0,value:null});const t=x.getDefaultClientConfig();this.apiUrl=P(e.apiUrl??t.apiUrl)??"",this.apiKey=P(e.apiKey??t.apiKey),this.webUrl=P(e.webUrl??t.webUrl),this.validateApiKeyIfHosted(),this.timeout_ms=e.timeout_ms??4e3,this.caller=new w(e.callerOptions??{})}static getDefaultClientConfig(){const e=O("LANGCHAIN_API_KEY");return{apiUrl:O("LANGCHAIN_ENDPOINT")??(e?"https://api.smith.langchain.com":"http://localhost:1984"),apiKey:e,webUrl:void 0}}validateApiKeyIfHosted(){if(!T(this.apiUrl)&&!this.apiKey)throw new Error("API key must be provided when using hosted LangSmith API")}getHostUrl(){return this.webUrl?this.webUrl:T(this.apiUrl)?(this.webUrl="http://localhost","http://localhost"):this.apiUrl.split(".",1)[0].includes("dev")?(this.webUrl="https://dev.smith.langchain.com","https://dev.smith.langchain.com"):(this.webUrl="https://smith.langchain.com","https://smith.langchain.com")}get headers(){const e={};return this.apiKey&&(e["x-api-key"]=`${this.apiKey}`),e}async _getResponse(e,t){const a=t?.toString()??"",r=`${this.apiUrl}${e}?${a}`,n=await this.caller.call(fetch,r,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!n.ok)throw new Error(`Failed to fetch ${e}: ${n.status} ${n.statusText}`);return n}async _get(e,t){return(await this._getResponse(e,t)).json()}async*_getPaginated(e,t=new URLSearchParams){let a=Number(t.get("offset"))||0;const r=Number(t.get("limit"))||100;for(;;){t.set("offset",String(a)),t.set("limit",String(r));const n=`${this.apiUrl}${e}?${t}`,i=await this.caller.call(fetch,n,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!i.ok)throw new Error(`Failed to fetch ${e}: ${i.status} ${i.statusText}`);const s=await i.json();if(0===s.length)break;if(yield s,s.length<r)break;a+=s.length}}async createRun(e){const t={...this.headers,"Content-Type":"application/json"},a=e.extra??{},r=await E(),n=e.project_name;delete e.project_name;const i={session_name:n,...e,extra:{...e.extra,runtime:{...r,...a.runtime}}};i.inputs=A(i.inputs),i.outputs&&(i.outputs=j(i.outputs));const s=await this.caller.call(fetch,`${this.apiUrl}/runs`,{method:"POST",headers:t,body:JSON.stringify(i),signal:AbortSignal.timeout(this.timeout_ms)});await S(s,"create run")}async updateRun(e,t){I(e),t.inputs&&(t.inputs=A(t.inputs)),t.outputs&&(t.outputs=j(t.outputs));const a={...this.headers,"Content-Type":"application/json"},r=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}`,{method:"PATCH",headers:a,body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms)});await S(r,"update run")}async readRun(e,{loadChildRuns:t}={loadChildRuns:!1}){I(e);let a=await this._get(`/runs/${e}`);return t&&a.child_run_ids&&(a=await this._loadChildRuns(a)),a}async getRunUrl({runId:e,run:t,projectOpts:a}){if(void 0!==t){let e;e=t.session_id?t.session_id:a?.projectName?(await this.readProject({projectName:a?.projectName})).id:a?.projectId?a?.projectId:(await this.readProject({projectName:O("LANGCHAIN_PROJECT")||"default"})).id;const r=await this._getTenantId();return`${this.getHostUrl()}/o/${r}/projects/p/${e}/r/${t.id}?poll=true`}if(void 0!==e){const t=await this.readRun(e);if(!t.app_path)throw new Error(`Run ${e} has no app_path`);return`${this.getHostUrl()}${t.app_path}`}throw new Error("Must provide either runId or run")}async _loadChildRuns(e){const t=await async function(e){const t=[];for await(const a of e)t.push(a);return t}(this.listRuns({id:e.child_run_ids})),a={},r={};t.sort(((e,t)=>(e?.dotted_order??"").localeCompare(t?.dotted_order??"")));for(const e of t){if(null===e.parent_run_id||void 0===e.parent_run_id)throw new Error(`Child run ${e.id} has no parent`);e.parent_run_id in a||(a[e.parent_run_id]=[]),a[e.parent_run_id].push(e),r[e.id]=e}e.child_runs=a[e.id]||[];for(const t in a)t!==e.id&&(r[t].child_runs=a[t]);return e}async*listRuns({projectId:e,projectName:t,parentRunId:a,referenceExampleId:r,startTime:n,executionOrder:i,runType:s,error:o,id:l,limit:c,offset:d,query:u,filter:h}){const p=new URLSearchParams;let m=e;if(t){if(e)throw new Error("Only one of projectId or projectName may be given");m=(await this.readProject({projectName:t})).id}if(m&&p.append("session",m),a&&p.append("parent_run",a),r&&p.append("reference_example",r),n&&p.append("start_time",n.toISOString()),i&&p.append("execution_order",i.toString()),s&&p.append("run_type",s),void 0!==o&&p.append("error",o.toString()),void 0!==l)for(const e of l)p.append("id",e);void 0!==c&&p.append("limit",c.toString()),void 0!==d&&p.append("offset",d.toString()),void 0!==u&&p.append("query",u),void 0!==h&&p.append("filter",h);for await(const e of this._getPaginated("/runs",p))yield*e}async shareRun(e,{shareId:t}={}){const a={run_id:e,share_token:t||r.Z()};I(e);const n=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"PUT",headers:this.headers,body:JSON.stringify(a),signal:AbortSignal.timeout(this.timeout_ms)}),i=await n.json();if(null===i||!("share_token"in i))throw new Error("Invalid response from server");return`${this.getHostUrl()}/public/${i.share_token}/r`}async unshareRun(e){I(e);const t=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});await S(t,"unshare run")}async readRunSharedLink(e){I(e);const t=await this.caller.call(fetch,`${this.apiUrl}/runs/${e}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)}),a=await t.json();if(null!==a&&"share_token"in a)return`${this.getHostUrl()}/public/${a.share_token}/r`}async listSharedRuns(e,{runIds:t}={}){const a=new URLSearchParams({share_token:e});if(void 0!==t)for(const e of t)a.append("id",e);I(e);const r=await this.caller.call(fetch,`${this.apiUrl}/public/${e}/runs${a}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});return await r.json()}async readDatasetSharedSchema(e,t){if(!e&&!t)throw new Error("Either datasetId or datasetName must be given");e||(e=(await this.readDataset({datasetName:t})).id),I(e);const a=await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)}),r=await a.json();return r.url=`${this.getHostUrl()}/public/${r.share_token}/d`,r}async shareDataset(e,t){if(!e&&!t)throw new Error("Either datasetId or datasetName must be given");e||(e=(await this.readDataset({datasetName:t})).id);const a={dataset_id:e};I(e);const r=await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"PUT",headers:this.headers,body:JSON.stringify(a),signal:AbortSignal.timeout(this.timeout_ms)}),n=await r.json();return n.url=`${this.getHostUrl()}/public/${n.share_token}/d`,n}async unshareDataset(e){I(e);const t=await this.caller.call(fetch,`${this.apiUrl}/datasets/${e}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});await S(t,"unshare dataset")}async readSharedDataset(e){I(e);const t=await this.caller.call(fetch,`${this.apiUrl}/public/${e}/datasets`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});return await t.json()}async createProject({projectName:e,projectExtra:t,upsert:a,referenceDatasetId:r}){const n=a?"?upsert=true":"",i=`${this.apiUrl}/sessions${n}`,s={name:e};void 0!==t&&(s.extra=t),void 0!==r&&(s.reference_dataset_id=r);const o=await this.caller.call(fetch,i,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(s),signal:AbortSignal.timeout(this.timeout_ms)}),l=await o.json();if(!o.ok)throw new Error(`Failed to create session ${e}: ${o.status} ${o.statusText}`);return l}async readProject({projectId:e,projectName:t}){let a="/sessions";const r=new URLSearchParams;if(void 0!==e&&void 0!==t)throw new Error("Must provide either projectName or projectId, not both");if(void 0!==e)I(e),a+=`/${e}`;else{if(void 0===t)throw new Error("Must provide projectName or projectId");r.append("name",t)}const n=await this._get(a,r);let i;if(Array.isArray(n)){if(0===n.length)throw new Error(`Project[id=${e}, name=${t}] not found`);i=n[0]}else i=n;return i}async _getTenantId(){if(null!==this._tenantId)return this._tenantId;const e=new URLSearchParams({limit:"1"});for await(const t of this._getPaginated("/sessions",e))return this._tenantId=t[0].tenant_id,t[0].tenant_id;throw new Error("No projects found to resolve tenant.")}async*listProjects({projectIds:e,name:t,nameContains:a,referenceDatasetId:r,referenceDatasetName:n,referenceFree:i}={}){const s=new URLSearchParams;if(void 0!==e)for(const t of e)s.append("id",t);if(void 0!==t&&s.append("name",t),void 0!==a&&s.append("name_contains",a),void 0!==r)s.append("reference_dataset",r);else if(void 0!==n){const e=await this.readDataset({datasetName:n});s.append("reference_dataset",e.id)}void 0!==i&&s.append("reference_free",i.toString());for await(const e of this._getPaginated("/sessions",s))yield*e}async deleteProject({projectId:e,projectName:t}){let a;if(void 0===e&&void 0===t)throw new Error("Must provide projectName or projectId");if(void 0!==e&&void 0!==t)throw new Error("Must provide either projectName or projectId, not both");a=void 0===e?(await this.readProject({projectName:t})).id:e,I(a);const r=await this.caller.call(fetch,`${this.apiUrl}/sessions/${a}`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});await S(r,`delete session ${a} (${t})`)}async uploadCsv({csvFile:e,fileName:t,inputKeys:a,outputKeys:r,description:n,dataType:i,name:s}){const o=`${this.apiUrl}/datasets/upload`,l=new FormData;l.append("file",e,t),a.forEach((e=>{l.append("input_keys",e)})),r.forEach((e=>{l.append("output_keys",e)})),n&&l.append("description",n),i&&l.append("data_type",i),s&&l.append("name",s);const c=await this.caller.call(fetch,o,{method:"POST",headers:this.headers,body:l,signal:AbortSignal.timeout(this.timeout_ms)});if(!c.ok){const e=await c.json();if(e.detail&&e.detail.includes("already exists"))throw new Error(`Dataset ${t} already exists`);throw new Error(`Failed to upload CSV: ${c.status} ${c.statusText}`)}return await c.json()}async createDataset(e,{description:t,dataType:a}={}){const r={name:e,description:t};a&&(r.data_type=a);const n=await this.caller.call(fetch,`${this.apiUrl}/datasets`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(r),signal:AbortSignal.timeout(this.timeout_ms)});if(!n.ok){const t=await n.json();if(t.detail&&t.detail.includes("already exists"))throw new Error(`Dataset ${e} already exists`);throw new Error(`Failed to create dataset ${n.status} ${n.statusText}`)}return await n.json()}async readDataset({datasetId:e,datasetName:t}){let a="/datasets";const r=new URLSearchParams({limit:"1"});if(void 0!==e&&void 0!==t)throw new Error("Must provide either datasetName or datasetId, not both");if(void 0!==e)I(e),a+=`/${e}`;else{if(void 0===t)throw new Error("Must provide datasetName or datasetId");r.append("name",t)}const n=await this._get(a,r);let i;if(Array.isArray(n)){if(0===n.length)throw new Error(`Dataset[id=${e}, name=${t}] not found`);i=n[0]}else i=n;return i}async readDatasetOpenaiFinetuning({datasetId:e,datasetName:t}){if(void 0!==e);else{if(void 0===t)throw new Error("Must provide datasetName or datasetId");e=(await this.readDataset({datasetName:t})).id}const a=await this._getResponse(`/datasets/${e}/openai_ft`);return(await a.text()).trim().split("\n").map((e=>JSON.parse(e)))}async*listDatasets({limit:e=100,offset:t=0,datasetIds:a,datasetName:r,datasetNameContains:n}={}){const i=new URLSearchParams({limit:e.toString(),offset:t.toString()});if(void 0!==a)for(const e of a)i.append("id",e);void 0!==r&&i.append("name",r),void 0!==n&&i.append("name_contains",n);for await(const e of this._getPaginated("/datasets",i))yield*e}async deleteDataset({datasetId:e,datasetName:t}){let a="/datasets",r=e;if(void 0!==e&&void 0!==t)throw new Error("Must provide either datasetName or datasetId, not both");if(void 0!==t&&(r=(await this.readDataset({datasetName:t})).id),void 0===r)throw new Error("Must provide datasetName or datasetId");I(r),a+=`/${r}`;const n=await this.caller.call(fetch,this.apiUrl+a,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!n.ok)throw new Error(`Failed to delete ${a}: ${n.status} ${n.statusText}`);await n.json()}async createExample(e,t,{datasetId:a,datasetName:r,createdAt:n,exampleId:i}){let s=a;if(void 0===s&&void 0===r)throw new Error("Must provide either datasetName or datasetId");if(void 0!==s&&void 0!==r)throw new Error("Must provide either datasetName or datasetId, not both");void 0===s&&(s=(await this.readDataset({datasetName:r})).id);const o={dataset_id:s,inputs:e,outputs:t,created_at:(n||new Date).toISOString(),id:i},l=await this.caller.call(fetch,`${this.apiUrl}/examples`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(o),signal:AbortSignal.timeout(this.timeout_ms)});if(!l.ok)throw new Error(`Failed to create example: ${l.status} ${l.statusText}`);return await l.json()}async createLLMExample(e,t,a){return this.createExample({input:e},{output:t},a)}async createChatExample(e,t,a){const r=e.map((e=>g(e)?b(e):e)),n=g(t)?b(t):t;return this.createExample({input:r},{output:n},a)}async readExample(e){I(e);const t=`/examples/${e}`;return await this._get(t)}async*listExamples({datasetId:e,datasetName:t,exampleIds:a}={}){let r;if(void 0!==e&&void 0!==t)throw new Error("Must provide either datasetName or datasetId, not both");if(void 0!==e)r=e;else{if(void 0===t)throw new Error("Must provide a datasetName or datasetId");r=(await this.readDataset({datasetName:t})).id}const n=new URLSearchParams({dataset:r});if(void 0!==a)for(const e of a)n.append("id",e);for await(const e of this._getPaginated("/examples",n))yield*e}async deleteExample(e){I(e);const t=`/examples/${e}`,a=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!a.ok)throw new Error(`Failed to delete ${t}: ${a.status} ${a.statusText}`);await a.json()}async updateExample(e,t){I(e);const a=await this.caller.call(fetch,`${this.apiUrl}/examples/${e}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(t),signal:AbortSignal.timeout(this.timeout_ms)});if(!a.ok)throw new Error(`Failed to update example ${e}: ${a.status} ${a.statusText}`);return await a.json()}async evaluateRun(e,t,{sourceInfo:a,loadChildRuns:r}={loadChildRuns:!1}){let n,i;if("string"==typeof e)n=await this.readRun(e,{loadChildRuns:r});else{if("object"!=typeof e||!("id"in e))throw new Error("Invalid run type: "+typeof e);n=e}null!==n.reference_example_id&&void 0!==n.reference_example_id&&(i=await this.readExample(n.reference_example_id));const s=await t.evaluateRun(n,i);let o=a??{};return s.evaluatorInfo&&(o={...o,...s.evaluatorInfo}),await this.createFeedback(n.id,s.key,{score:s.score,value:s.value,comment:s.comment,correction:s.correction,sourceInfo:o,feedbackSourceType:"model"})}async createFeedback(e,t,{score:a,value:n,correction:i,comment:s,sourceInfo:o,feedbackSourceType:l="api",sourceRunId:c,feedbackId:d,eager:u=!1}){const h={type:l??"api",metadata:o??{}};void 0===c||void 0===h?.metadata||h.metadata.__run||(h.metadata.__run={run_id:c}),void 0!==h?.metadata&&void 0!==h.metadata.__run?.run_id&&I(h.metadata.__run.run_id);const p={id:d??r.Z(),run_id:e,key:t,score:a,value:n,correction:i,comment:s,feedback_source:h},m=`${this.apiUrl}/feedback`+(u?"/eager":""),f=await this.caller.call(fetch,m,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(p),signal:AbortSignal.timeout(this.timeout_ms)});return await S(f,"create feedback"),p}async updateFeedback(e,{score:t,value:a,correction:r,comment:n}){const i={};null!=t&&(i.score=t),null!=a&&(i.value=a),null!=r&&(i.correction=r),null!=n&&(i.comment=n),I(e);const s=await this.caller.call(fetch,`${this.apiUrl}/feedback/${e}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify(i),signal:AbortSignal.timeout(this.timeout_ms)});await S(s,"update feedback")}async readFeedback(e){I(e);const t=`/feedback/${e}`;return await this._get(t)}async deleteFeedback(e){I(e);const t=`/feedback/${e}`,a=await this.caller.call(fetch,this.apiUrl+t,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms)});if(!a.ok)throw new Error(`Failed to delete ${t}: ${a.status} ${a.statusText}`);await a.json()}async*listFeedback({runIds:e,feedbackKeys:t,feedbackSourceTypes:a}={}){const r=new URLSearchParams;if(e&&r.append("run",e.join(",")),t)for(const e of t)r.append("key",e);if(a)for(const e of a)r.append("source",e);for await(const e of this._getPaginated("/feedback",r))yield*e}}var R=a(75606);class C extends s.Z{constructor(e={}){super(e),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"langchain_tracer"}),Object.defineProperty(this,"projectName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"exampleId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"client",{enumerable:!0,configurable:!0,writable:!0,value:void 0});const{exampleId:t,projectName:a,client:r}=e;this.projectName=a??(0,R.lS)("LANGCHAIN_PROJECT")??(0,R.lS)("LANGCHAIN_SESSION"),this.exampleId=t,this.client=r??new x({})}async _convertToCreate(e,t=void 0){return{...e,extra:{...e.extra,runtime:await(0,R.sA)()},child_runs:void 0,session_name:this.projectName,reference_example_id:e.parent_run_id?void 0:t}}async persistRun(e){}async _persistRunSingle(e){const t=await this._convertToCreate(e,this.exampleId);await this.client.createRun(t)}async _updateRunSingle(e){const t={end_time:e.end_time,error:e.error,outputs:e.outputs,events:e.events,inputs:e.inputs};await this.client.updateRun(e.id,t)}async onRetrieverStart(e){await this._persistRunSingle(e)}async onRetrieverEnd(e){await this._updateRunSingle(e)}async onRetrieverError(e){await this._updateRunSingle(e)}async onLLMStart(e){await this._persistRunSingle(e)}async onLLMEnd(e){await this._updateRunSingle(e)}async onLLMError(e){await this._updateRunSingle(e)}async onChainStart(e){await this._persistRunSingle(e)}async onChainEnd(e){await this._updateRunSingle(e)}async onChainError(e){await this._updateRunSingle(e)}async onToolStart(e){await this._persistRunSingle(e)}async onToolEnd(e){await this._updateRunSingle(e)}async onToolError(e){await this._updateRunSingle(e)}}var N=a(37967);class $ extends s.Z{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"langchain_tracer"}),Object.defineProperty(this,"endpoint",{enumerable:!0,configurable:!0,writable:!0,value:(0,R.lS)("LANGCHAIN_ENDPOINT")||"http://localhost:1984"}),Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:{"Content-Type":"application/json"}}),Object.defineProperty(this,"session",{enumerable:!0,configurable:!0,writable:!0,value:void 0});const e=(0,R.lS)("LANGCHAIN_API_KEY");e&&(this.headers["x-api-key"]=e)}async newSession(e){const t={start_time:Date.now(),name:e},a=await this.persistSession(t);return this.session=a,a}async loadSession(e){const t=`${this.endpoint}/sessions?name=${e}`;return this._handleSessionResponse(t)}async loadDefaultSession(){const e=`${this.endpoint}/sessions?name=default`;return this._handleSessionResponse(e)}async convertV2RunToRun(e){const t=this.session??await this.loadDefaultSession(),a=e.serialized;let r;if("llm"===e.run_type){const n=e.inputs.prompts?e.inputs.prompts:e.inputs.messages.map((e=>(0,N.zs)(e)));r={uuid:e.id,start_time:e.start_time,end_time:e.end_time,execution_order:e.execution_order,child_execution_order:e.child_execution_order,serialized:a,type:e.run_type,session_id:t.id,prompts:n,response:e.outputs}}else if("chain"===e.run_type){const n=await Promise.all(e.child_runs.map((e=>this.convertV2RunToRun(e))));r={uuid:e.id,start_time:e.start_time,end_time:e.end_time,execution_order:e.execution_order,child_execution_order:e.child_execution_order,serialized:a,type:e.run_type,session_id:t.id,inputs:e.inputs,outputs:e.outputs,child_llm_runs:n.filter((e=>"llm"===e.type)),child_chain_runs:n.filter((e=>"chain"===e.type)),child_tool_runs:n.filter((e=>"tool"===e.type))}}else{if("tool"!==e.run_type)throw new Error(`Unknown run type: ${e.run_type}`);{const n=await Promise.all(e.child_runs.map((e=>this.convertV2RunToRun(e))));r={uuid:e.id,start_time:e.start_time,end_time:e.end_time,execution_order:e.execution_order,child_execution_order:e.child_execution_order,serialized:a,type:e.run_type,session_id:t.id,tool_input:e.inputs.input,output:e.outputs?.output,action:JSON.stringify(a),child_llm_runs:n.filter((e=>"llm"===e.type)),child_chain_runs:n.filter((e=>"chain"===e.type)),child_tool_runs:n.filter((e=>"tool"===e.type))}}}return r}async persistRun(e){let t,a;a=void 0!==e.run_type?await this.convertV2RunToRun(e):e,t="llm"===a.type?`${this.endpoint}/llm-runs`:"chain"===a.type?`${this.endpoint}/chain-runs`:`${this.endpoint}/tool-runs`;const r=await fetch(t,{method:"POST",headers:this.headers,body:JSON.stringify(a)});r.ok||console.error(`Failed to persist run: ${r.status} ${r.statusText}`)}async persistSession(e){const t=`${this.endpoint}/sessions`,a=await fetch(t,{method:"POST",headers:this.headers,body:JSON.stringify(e)});return a.ok?{id:(await a.json()).id,...e}:(console.error(`Failed to persist session: ${a.status} ${a.statusText}, using default session.`),{id:1,...e})}async _handleSessionResponse(e){const t=await fetch(e,{method:"GET",headers:this.headers});let a;if(!t.ok)return console.error(`Failed to load session: ${t.status} ${t.statusText}`),a={id:1,start_time:Date.now()},this.session=a,a;const r=await t.json();return 0===r.length?(a={id:1,start_time:Date.now()},this.session=a,a):([a]=r,this.session=a,a)}}let k;async function M(e,t){!0===t?await e():(void 0===k&&(k=new(0,m.default)({autoStart:!0,concurrency:1})),k.add(e))}class L{setHandler(e){return this.setHandlers([e])}}class D{constructor(e,t,a,r,n,i,s,o){Object.defineProperty(this,"runId",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:a}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:r}),Object.defineProperty(this,"inheritableTags",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:i}),Object.defineProperty(this,"inheritableMetadata",{enumerable:!0,configurable:!0,writable:!0,value:s}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:o})}async handleText(e){await Promise.all(this.handlers.map((t=>M((async()=>{try{await(t.handleText?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleText: ${e}`)}}),t.awaitHandlers))))}}class H extends D{getChild(e){const t=new J(this.runId);return t.setHandlers(this.inheritableHandlers),t.addTags(this.inheritableTags),t.addMetadata(this.inheritableMetadata),e&&t.addTags([e],!1),t}async handleRetrieverEnd(e){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreRetriever)try{await(t.handleRetrieverEnd?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleRetriever`)}}),t.awaitHandlers))))}async handleRetrieverError(e){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreRetriever)try{await(t.handleRetrieverError?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleRetrieverError: ${e}`)}}),t.awaitHandlers))))}}class U extends D{async handleLLMNewToken(e,t,a,r,n,i){await Promise.all(this.handlers.map((a=>M((async()=>{if(!a.ignoreLLM)try{await(a.handleLLMNewToken?.(e,t??{prompt:0,completion:0},this.runId,this._parentRunId,this.tags,i))}catch(e){console.error(`Error in handler ${a.constructor.name}, handleLLMNewToken: ${e}`)}}),a.awaitHandlers))))}async handleLLMError(e){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreLLM)try{await(t.handleLLMError?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleLLMError: ${e}`)}}),t.awaitHandlers))))}async handleLLMEnd(e){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreLLM)try{await(t.handleLLMEnd?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleLLMEnd: ${e}`)}}),t.awaitHandlers))))}}class F extends D{getChild(e){const t=new J(this.runId);return t.setHandlers(this.inheritableHandlers),t.addTags(this.inheritableTags),t.addMetadata(this.inheritableMetadata),e&&t.addTags([e],!1),t}async handleChainError(e,t,a,r,n){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreChain)try{await(t.handleChainError?.(e,this.runId,this._parentRunId,this.tags,n))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleChainError: ${e}`)}}),t.awaitHandlers))))}async handleChainEnd(e,t,a,r,n){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreChain)try{await(t.handleChainEnd?.(e,this.runId,this._parentRunId,this.tags,n))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleChainEnd: ${e}`)}}),t.awaitHandlers))))}async handleAgentAction(e){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreAgent)try{await(t.handleAgentAction?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleAgentAction: ${e}`)}}),t.awaitHandlers))))}async handleAgentEnd(e){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreAgent)try{await(t.handleAgentEnd?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleAgentEnd: ${e}`)}}),t.awaitHandlers))))}}class B extends D{getChild(e){const t=new J(this.runId);return t.setHandlers(this.inheritableHandlers),t.addTags(this.inheritableTags),t.addMetadata(this.inheritableMetadata),e&&t.addTags([e],!1),t}async handleToolError(e){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreAgent)try{await(t.handleToolError?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleToolError: ${e}`)}}),t.awaitHandlers))))}async handleToolEnd(e){await Promise.all(this.handlers.map((t=>M((async()=>{if(!t.ignoreAgent)try{await(t.handleToolEnd?.(e,this.runId,this._parentRunId,this.tags))}catch(e){console.error(`Error in handler ${t.constructor.name}, handleToolEnd: ${e}`)}}),t.awaitHandlers))))}}class J extends L{constructor(e){super(),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"inheritableTags",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"inheritableMetadata",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"callback_manager"}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.handlers=[],this.inheritableHandlers=[],this._parentRunId=e}async handleLLMStart(e,t,a=void 0,n=void 0,i=void 0,s=void 0,o=void 0,l=void 0){return Promise.all(t.map((async t=>{const a=(0,r.Z)();return await Promise.all(this.handlers.map((r=>M((async()=>{if(!r.ignoreLLM)try{await(r.handleLLMStart?.(e,[t],a,this._parentRunId,i,this.tags,this.metadata,l))}catch(e){console.error(`Error in handler ${r.constructor.name}, handleLLMStart: ${e}`)}}),r.awaitHandlers)))),new U(a,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)})))}async handleChatModelStart(e,t,a=void 0,n=void 0,i=void 0,s=void 0,o=void 0,l=void 0){return Promise.all(t.map((async t=>{const a=(0,r.Z)();return await Promise.all(this.handlers.map((r=>M((async()=>{if(!r.ignoreLLM)try{if(r.handleChatModelStart)await(r.handleChatModelStart?.(e,[t],a,this._parentRunId,i,this.tags,this.metadata,l));else if(r.handleLLMStart){const n=(0,N.zs)(t);await(r.handleLLMStart?.(e,[n],a,this._parentRunId,i,this.tags,this.metadata,l))}}catch(e){console.error(`Error in handler ${r.constructor.name}, handleLLMStart: ${e}`)}}),r.awaitHandlers)))),new U(a,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)})))}async handleChainStart(e,t,a=(0,r.Z)(),n=void 0,i=void 0,s=void 0,o=void 0){return await Promise.all(this.handlers.map((r=>M((async()=>{if(!r.ignoreChain)try{await(r.handleChainStart?.(e,t,a,this._parentRunId,this.tags,this.metadata,n,o))}catch(e){console.error(`Error in handler ${r.constructor.name}, handleChainStart: ${e}`)}}),r.awaitHandlers)))),new F(a,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}async handleToolStart(e,t,a=(0,r.Z)(),n=void 0,i=void 0,s=void 0,o=void 0){return await Promise.all(this.handlers.map((r=>M((async()=>{if(!r.ignoreAgent)try{await(r.handleToolStart?.(e,t,a,this._parentRunId,this.tags,this.metadata,o))}catch(e){console.error(`Error in handler ${r.constructor.name}, handleToolStart: ${e}`)}}),r.awaitHandlers)))),new B(a,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}async handleRetrieverStart(e,t,a=(0,r.Z)(),n=void 0,i=void 0,s=void 0,o=void 0){return await Promise.all(this.handlers.map((r=>M((async()=>{if(!r.ignoreRetriever)try{await(r.handleRetrieverStart?.(e,t,a,this._parentRunId,this.tags,this.metadata,o))}catch(e){console.error(`Error in handler ${r.constructor.name}, handleRetrieverStart: ${e}`)}}),r.awaitHandlers)))),new H(a,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}addHandler(e,t=!0){this.handlers.push(e),t&&this.inheritableHandlers.push(e)}removeHandler(e){this.handlers=this.handlers.filter((t=>t!==e)),this.inheritableHandlers=this.inheritableHandlers.filter((t=>t!==e))}setHandlers(e,t=!0){this.handlers=[],this.inheritableHandlers=[];for(const a of e)this.addHandler(a,t)}addTags(e,t=!0){this.removeTags(e),this.tags.push(...e),t&&this.inheritableTags.push(...e)}removeTags(e){this.tags=this.tags.filter((t=>!e.includes(t))),this.inheritableTags=this.inheritableTags.filter((t=>!e.includes(t)))}addMetadata(e,t=!0){this.metadata={...this.metadata,...e},t&&(this.inheritableMetadata={...this.inheritableMetadata,...e})}removeMetadata(e){for(const t of Object.keys(e))delete this.metadata[t],delete this.inheritableMetadata[t]}copy(e=[],t=!0){const a=new J(this._parentRunId);for(const e of this.handlers){const t=this.inheritableHandlers.includes(e);a.addHandler(e,t)}for(const e of this.tags){const t=this.inheritableTags.includes(e);a.addTags([e],t)}for(const e of Object.keys(this.metadata)){const t=Object.keys(this.inheritableMetadata).includes(e);a.addMetadata({[e]:this.metadata[e]},t)}for(const r of e)a.handlers.filter((e=>"console_callback_handler"===e.name)).some((e=>e.name===r.name))||a.addHandler(r,t);return a}static fromHandlers(e){class t extends n.E{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:(0,r.Z)()}),Object.assign(this,e)}}const a=new this;return a.addHandler(new t),a}static async configure(e,t,a,r,n,i,s){let o;(e||t)&&(Array.isArray(e)||!e?(o=new J,o.setHandlers(e?.map(V)??[],!0)):o=e,o=o.copy(Array.isArray(t)?t.map(V):t?.handlers,!1));const l="true"===(0,R.lS)("LANGCHAIN_VERBOSE")||s?.verbose,c="true"===(0,R.lS)("LANGCHAIN_TRACING_V2"),d=c||((0,R.lS)("LANGCHAIN_TRACING")??!1);if(l||d){if(o||(o=new J),l&&!o.handlers.some((e=>e.name===u.prototype.name))){const e=new u;o.addHandler(e,!0)}if(d&&!o.handlers.some((e=>"langchain_tracer"===e.name)))if(c)o.addHandler(await async function(){return new C}(),!0);else{const e=(0,R.lS)("LANGCHAIN_PROJECT")&&(0,R.lS)("LANGCHAIN_SESSION");o.addHandler(await async function(e){const t=new $;return e?await t.loadSession(e):await t.loadDefaultSession(),t}(e),!0)}}return(a||r)&&o&&(o.addTags(a??[]),o.addTags(r??[],!1)),(n||i)&&o&&(o.addMetadata(n??{}),o.addMetadata(i??{},!1)),o}}function V(e){return"name"in e?e:n.E.fromMethods(e)}},32385:(e,t,a)=>{a.d(t,{i:()=>c,j:()=>l});var r=a(2466);function n(e,t){return t?.[e]||r(e)}function i(e,t,a){const r={};for(const n in e)Object.hasOwn(e,n)&&(r[t(n,a)]=e[n]);return r}function s(e){return Array.isArray(e)?[...e]:{...e}}function o(e,t){const a=s(e);for(const[e,r]of Object.entries(t)){const[t,...n]=e.split(".").reverse();let i=a;for(const e of n.reverse()){if(void 0===i[e])break;i[e]=s(i[e]),i=i[e]}void 0!==i[t]&&(i[t]={lc:1,type:"secret",id:[r]})}return a}function l(e){const t=Object.getPrototypeOf(e);return"function"!=typeof e.lc_name||"function"==typeof t.lc_name&&e.lc_name()===t.lc_name()?e.name:e.lc_name()}a(83257);class c{static lc_name(){return this.name}get lc_id(){return[...this.lc_namespace,l(this.constructor)]}get lc_secrets(){}get lc_attributes(){}get lc_aliases(){}constructor(e,...t){Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"lc_kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.lc_kwargs=e||{}}toJSON(){if(!this.lc_serializable)return this.toJSONNotImplemented();if(this.lc_kwargs instanceof c||"object"!=typeof this.lc_kwargs||Array.isArray(this.lc_kwargs))return this.toJSONNotImplemented();const e={},t={},a=Object.keys(this.lc_kwargs).reduce(((e,t)=>(e[t]=t in this?this[t]:this.lc_kwargs[t],e)),{});for(let r=Object.getPrototypeOf(this);r;r=Object.getPrototypeOf(r))Object.assign(e,Reflect.get(r,"lc_aliases",this)),Object.assign(t,Reflect.get(r,"lc_secrets",this)),Object.assign(a,Reflect.get(r,"lc_attributes",this));return Object.keys(t).forEach((e=>{let t=this,r=a;const[n,...i]=e.split(".").reverse();for(const e of i.reverse()){if(!(e in t)||void 0===t[e])return;e in r&&void 0!==r[e]||("object"==typeof t[e]&&null!=t[e]?r[e]={}:Array.isArray(t[e])&&(r[e]=[])),t=t[e],r=r[e]}n in t&&void 0!==t[n]&&(r[n]=r[n]||t[n])})),{lc:1,type:"constructor",id:this.lc_id,kwargs:i(Object.keys(t).length?o(a,t):a,n,e)}}toJSONNotImplemented(){return{lc:1,type:"not_implemented",id:this.lc_id}}}},37967:(e,t,a)=>{function r(e,t="Human",a="AI"){const r=[];for(const n of e){let e;if("human"===n._getType())e=t;else if("ai"===n._getType())e=a;else if("system"===n._getType())e="System";else if("function"===n._getType())e="Function";else{if("generic"!==n._getType())throw new Error(`Got unsupported message type: ${n}`);e=n.role}const i=n.name?`${n.name}, `:"";r.push(`${e}: ${i}${n.content}`)}return r.join("\n")}a.d(t,{zs:()=>r})},5962:(e,t,a)=>{a.d(t,{Al:()=>o,nw:()=>i});var r=a(26134),n=(a(32385),a(60018));class i extends r.MJ{constructor(e){super({value:e}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","prompts","base"]}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.value=e}toString(){return this.value}toChatMessages(){return[new r.xk(this.value)]}}class s extends n.eq{get lc_attributes(){return{partialVariables:void 0}}constructor(e){super(e),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","prompts",this._getPromptType()]}),Object.defineProperty(this,"inputVariables",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"outputParser",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"partialVariables",{enumerable:!0,configurable:!0,writable:!0,value:void 0});const{inputVariables:t}=e;if(t.includes("stop"))throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.");Object.assign(this,e)}async mergePartialAndUserVariables(e){const t=this.partialVariables??{},a={};for(const[e,r]of Object.entries(t))a[e]="string"==typeof r?r:await r();return{...a,...e}}async invoke(e,t){return this._callWithConfig((e=>this.formatPromptValue(e)),e,{...t,runType:"prompt"})}serialize(){throw new Error("Use .toJSON() instead")}static async deserialize(e){switch(e._type){case"prompt":{const{PromptTemplate:t}=await Promise.resolve().then(a.bind(a,76430));return t.deserialize(e)}case void 0:{const{PromptTemplate:t}=await Promise.resolve().then(a.bind(a,76430));return t.deserialize({...e,_type:"prompt"})}case"few_shot":{const{FewShotPromptTemplate:t}=await a.e(832).then(a.bind(a,62832));return t.deserialize(e)}default:throw new Error(`Invalid prompt type in config: ${e._type}`)}}}class o extends s{async formatPromptValue(e){const t=await this.format(e);return new i(t)}}},76430:(e,t,a)=>{a.d(t,{PromptTemplate:()=>i});var r=a(5962),n=a(55738);class i extends r.Al{static lc_name(){return"PromptTemplate"}constructor(e){if(super(e),Object.defineProperty(this,"template",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"templateFormat",{enumerable:!0,configurable:!0,writable:!0,value:"f-string"}),Object.defineProperty(this,"validateTemplate",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.assign(this,e),this.validateTemplate){let e=this.inputVariables;this.partialVariables&&(e=e.concat(Object.keys(this.partialVariables))),(0,n.af)(this.template,this.templateFormat,e)}}_getPromptType(){return"prompt"}async format(e){const t=await this.mergePartialAndUserVariables(e);return(0,n.SM)(this.template,this.templateFormat,t)}static fromExamples(e,t,a,r="\n\n",n=""){const s=[n,...e,t].join(r);return new i({inputVariables:a,template:s})}static fromTemplate(e,{templateFormat:t="f-string",...a}={}){const r=new Set;return(0,n.$M)(e,t).forEach((e=>{"variable"===e.type&&r.add(e.name)})),new i({inputVariables:[...r],templateFormat:t,template:e,...a})}async partial(e){const t=this.inputVariables.filter((t=>!(t in e))),a={...this.partialVariables??{},...e},r={...this,inputVariables:t,partialVariables:a};return new i(r)}serialize(){if(void 0!==this.outputParser)throw new Error("Cannot serialize a prompt template with an output parser");return{_type:this._getPromptType(),input_variables:this.inputVariables,template:this.template,template_format:this.templateFormat}}static async deserialize(e){if(!e.template)throw new Error("Prompt template must have a template");return new i({inputVariables:e.input_variables,template:e.template,templateFormat:e.template_format})}}},55738:(e,t,a)=>{a.d(t,{$M:()=>o,SM:()=>s,af:()=>l});const r=e=>{const t=e.split(""),a=[],r=(e,a)=>{for(let r=a;r<t.length;r+=1)if(e.includes(t[r]))return r;return-1};let n=0;for(;n<t.length;)if("{"===t[n]&&n+1<t.length&&"{"===t[n+1])a.push({type:"literal",text:"{"}),n+=2;else if("}"===t[n]&&n+1<t.length&&"}"===t[n+1])a.push({type:"literal",text:"}"}),n+=2;else if("{"===t[n]){const e=r("}",n);if(e<0)throw new Error("Unclosed '{' in template.");a.push({type:"variable",name:t.slice(n+1,e).join("")}),n=e+1}else{if("}"===t[n])throw new Error("Single '}' in template.");{const e=r("{}",n),i=(e<0?t.slice(n):t.slice(n,e)).join("");a.push({type:"literal",text:i}),n=e<0?t.length:e}}return a},n={"f-string":(e,t)=>r(e).reduce(((e,a)=>{if("variable"===a.type){if(a.name in t)return e+t[a.name];throw new Error(`Missing value for input ${a.name}`)}return e+a.text}),"")},i={"f-string":r},s=(e,t,a)=>n[t](e,a),o=(e,t)=>i[t](e),l=(e,t,a)=>{if(!(t in n)){const e=Object.keys(n);throw new Error(`Invalid template format. Got \`${t}\`;\n                         should be one of ${e}`)}try{const r=a.reduce(((e,t)=>(e[t]="foo",e)),{});s(e,t,r)}catch(e){throw new Error(`Invalid prompt schema: ${e.message}`)}}},26134:(e,t,a)=>{a.d(t,{Cr:()=>w,E1:()=>y,GC:()=>p,H2:()=>O,HD:()=>_,J:()=>b,Ls:()=>v,MJ:()=>E,WH:()=>n,Xz:()=>g,gY:()=>h,ro:()=>u,xk:()=>d,xq:()=>f});var r=a(32385);const n="__run";class i{constructor(e){Object.defineProperty(this,"text",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"generationInfo",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.text=e.text,this.generationInfo=e.generationInfo}concat(e){return new i({text:this.text+e.text,generationInfo:{...this.generationInfo,...e.generationInfo}})}}function s(e,t){return"string"==typeof e?"string"==typeof t?e+t:[{type:"text",text:e},...t]:Array.isArray(t)?[...e,...t]:[...e,{type:"text",text:t}]}class o extends r.i{get text(){return"string"==typeof this.content?this.content:""}constructor(e,t){"string"==typeof e&&(e={content:e,additional_kwargs:t}),e.additional_kwargs||(e.additional_kwargs={}),super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","schema"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"content",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"additional_kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=e.name,this.content=e.content,this.additional_kwargs=e.additional_kwargs}toDict(){return{type:this._getType(),data:this.toJSON().kwargs}}toChunk(){const e=this._getType();if("human"===e)return new u({...this});if("ai"===e)return new p({...this});if("system"===e)return new f({...this});if("function"===e)return new w({...this});if(b.isInstance(this))return new _({...this});throw new Error("Unknown message type.")}}function l(e){return Array.isArray(e)&&e.every((e=>"number"==typeof e.index))}class c extends o{static _mergeAdditionalKwargs(e,t){const a={...e};for(const[e,r]of Object.entries(t))if(void 0===a[e])a[e]=r;else{if(typeof a[e]!=typeof r)throw new Error(`additional_kwargs[${e}] already exists in the message chunk, but with a different type.`);if("string"==typeof a[e])a[e]=a[e]+r;else if(Array.isArray(a[e])||"object"!=typeof a[e]){if("tool_calls"!==e||!l(a[e])||!l(r))throw new Error(`additional_kwargs[${e}] already exists in this message chunk.`);for(const t of r)void 0!==a[e]?.[t.index]?a[e]=a[e]?.map(((e,a)=>a!==t.index?e:{...e,...t,function:{name:t.function.name??e.function.name,arguments:(e.function.arguments??"")+(t.function.arguments??"")}})):a[e][t.index]=t}else a[e]=this._mergeAdditionalKwargs(a[e],r)}return a}}class d extends o{static lc_name(){return"HumanMessage"}_getType(){return"human"}}class u extends c{static lc_name(){return"HumanMessageChunk"}_getType(){return"human"}concat(e){return new u({content:s(this.content,e.content),additional_kwargs:u._mergeAdditionalKwargs(this.additional_kwargs,e.additional_kwargs)})}}class h extends o{static lc_name(){return"AIMessage"}_getType(){return"ai"}}class p extends c{static lc_name(){return"AIMessageChunk"}_getType(){return"ai"}concat(e){return new p({content:s(this.content,e.content),additional_kwargs:p._mergeAdditionalKwargs(this.additional_kwargs,e.additional_kwargs)})}}class m extends o{static lc_name(){return"SystemMessage"}_getType(){return"system"}}class f extends c{static lc_name(){return"SystemMessageChunk"}_getType(){return"system"}concat(e){return new f({content:s(this.content,e.content),additional_kwargs:f._mergeAdditionalKwargs(this.additional_kwargs,e.additional_kwargs)})}}class w extends c{static lc_name(){return"FunctionMessageChunk"}_getType(){return"function"}concat(e){return new w({content:s(this.content,e.content),additional_kwargs:w._mergeAdditionalKwargs(this.additional_kwargs,e.additional_kwargs),name:this.name??""})}}class g extends c{constructor(e){super(e),Object.defineProperty(this,"tool_call_id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.tool_call_id=e.tool_call_id}static lc_name(){return"ToolMessageChunk"}_getType(){return"tool"}concat(e){return new g({content:s(this.content,e.content),additional_kwargs:g._mergeAdditionalKwargs(this.additional_kwargs,e.additional_kwargs),tool_call_id:this.tool_call_id})}}class b extends o{static lc_name(){return"ChatMessage"}constructor(e,t){"string"==typeof e&&(e={content:e,role:t}),super(e),Object.defineProperty(this,"role",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.role=e.role}_getType(){return"generic"}static isInstance(e){return"generic"===e._getType()}}function y(e){if("string"==typeof e)return new d(e);if(function(e){return"function"==typeof e?._getType}(e))return e;const[t,a]=e;if("human"===t||"user"===t)return new d({content:a});if("ai"===t||"assistant"===t)return new h({content:a});if("system"===t)return new m({content:a});throw new Error("Unable to coerce message from array: only human, AI, or system message coercion is currently supported.")}class _ extends c{static lc_name(){return"ChatMessageChunk"}constructor(e,t){"string"==typeof e&&(e={content:e,role:t}),super(e),Object.defineProperty(this,"role",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.role=e.role}_getType(){return"generic"}concat(e){return new _({content:s(this.content,e.content),additional_kwargs:_._mergeAdditionalKwargs(this.additional_kwargs,e.additional_kwargs),role:this.role})}}class v extends i{constructor(e){super(e),Object.defineProperty(this,"message",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.message=e.message}concat(e){return new v({text:this.text+e.text,generationInfo:{...this.generationInfo,...e.generationInfo},message:this.message.concat(e.message)})}}class E extends r.i{}class O{}},60018:(e,t,a)=>{a.d(t,{eq:()=>N});var r={};a.r(r),a.d(r,{JsonPatchError:()=>p,_areEquals:()=>O,applyOperation:()=>b,applyPatch:()=>y,applyReducer:()=>_,deepClone:()=>m,getValueByPointer:()=>g,validate:()=>E,validator:()=>v});var n=a(42693),i=a(49354);const s=Object.prototype.hasOwnProperty;function o(e,t){return s.call(e,t)}function l(e){switch(typeof e){case"object":return JSON.parse(JSON.stringify(e));case"undefined":return null;default:return e}}function c(e){let t=0;const a=e.length;let r;for(;t<a;){if(r=e.charCodeAt(t),!(r>=48&&r<=57))return!1;t++}return!0}function d(e){if(void 0===e)return!0;if(e)if(Array.isArray(e)){for(let t=0,a=e.length;t<a;t++)if(d(e[t]))return!0}else if("object"==typeof e){const a=function(e){if(Array.isArray(e)){const t=new Array(e.length);for(let e=0;e<t.length;e++)t[e]=""+e;return t}if(Object.keys)return Object.keys(e);let t=[];for(let a in e)o(e,a)&&t.push(a);return t}(e),r=a.length;for(var t=0;t<r;t++)if(d(e[a[t]]))return!0}return!1}function u(e,t){const a=[e];for(const e in t){const r="object"==typeof t[e]?JSON.stringify(t[e],null,2):t[e];void 0!==r&&a.push(`${e}: ${r}`)}return a.join("\n")}class h extends Error{constructor(e,t,a,r,n){super(u(e,{name:t,index:a,operation:r,tree:n})),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"index",{enumerable:!0,configurable:!0,writable:!0,value:a}),Object.defineProperty(this,"operation",{enumerable:!0,configurable:!0,writable:!0,value:r}),Object.defineProperty(this,"tree",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.setPrototypeOf(this,new.target.prototype),this.message=u(e,{name:t,index:a,operation:r,tree:n})}}const p=h,m=l,f={add:function(e,t,a){return e[t]=this.value,{newDocument:a}},remove:function(e,t,a){var r=e[t];return delete e[t],{newDocument:a,removed:r}},replace:function(e,t,a){var r=e[t];return e[t]=this.value,{newDocument:a,removed:r}},move:function(e,t,a){let r=g(a,this.path);r&&(r=l(r));const n=b(a,{op:"remove",path:this.from}).removed;return b(a,{op:"add",path:this.path,value:n}),{newDocument:a,removed:r}},copy:function(e,t,a){const r=g(a,this.from);return b(a,{op:"add",path:this.path,value:l(r)}),{newDocument:a}},test:function(e,t,a){return{newDocument:a,test:O(e[t],this.value)}},_get:function(e,t,a){return this.value=e[t],{newDocument:a}}};var w={add:function(e,t,a){return c(t)?e.splice(t,0,this.value):e[t]=this.value,{newDocument:a,index:t}},remove:function(e,t,a){return{newDocument:a,removed:e.splice(t,1)[0]}},replace:function(e,t,a){var r=e[t];return e[t]=this.value,{newDocument:a,removed:r}},move:f.move,copy:f.copy,test:f.test,_get:f._get};function g(e,t){if(""==t)return e;var a={op:"_get",path:t};return b(e,a),a.value}function b(e,t,a=!1,r=!0,n=!0,i=0){if(a&&("function"==typeof a?a(t,0,e,t.path):v(t,0)),""===t.path){let r={newDocument:e};if("add"===t.op)return r.newDocument=t.value,r;if("replace"===t.op)return r.newDocument=t.value,r.removed=e,r;if("move"===t.op||"copy"===t.op)return r.newDocument=g(e,t.from),"move"===t.op&&(r.removed=e),r;if("test"===t.op){if(r.test=O(e,t.value),!1===r.test)throw new p("Test operation failed","TEST_OPERATION_FAILED",i,t,e);return r.newDocument=e,r}if("remove"===t.op)return r.removed=e,r.newDocument=null,r;if("_get"===t.op)return t.value=e,r;if(a)throw new p("Operation `op` property is not one of operations defined in RFC-6902","OPERATION_OP_INVALID",i,t,e);return r}{r||(e=l(e));const s=(t.path||"").split("/");let o,d,u,h=e,m=1,g=s.length;for(u="function"==typeof a?a:v;;){if(d=s[m],d&&-1!=d.indexOf("~")&&(d=d.replace(/~1/g,"/").replace(/~0/g,"~")),n&&("__proto__"==d||"prototype"==d&&m>0&&"constructor"==s[m-1]))throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");if(a&&void 0===o&&(void 0===h[d]?o=s.slice(0,m).join("/"):m==g-1&&(o=t.path),void 0!==o&&u(t,0,e,o)),m++,Array.isArray(h)){if("-"===d)d=h.length;else{if(a&&!c(d))throw new p("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index","OPERATION_PATH_ILLEGAL_ARRAY_INDEX",i,t,e);c(d)&&(d=~~d)}if(m>=g){if(a&&"add"===t.op&&d>h.length)throw new p("The specified index MUST NOT be greater than the number of elements in the array","OPERATION_VALUE_OUT_OF_BOUNDS",i,t,e);const r=w[t.op].call(t,h,d,e);if(!1===r.test)throw new p("Test operation failed","TEST_OPERATION_FAILED",i,t,e);return r}}else if(m>=g){const a=f[t.op].call(t,h,d,e);if(!1===a.test)throw new p("Test operation failed","TEST_OPERATION_FAILED",i,t,e);return a}if(h=h[d],a&&m<g&&(!h||"object"!=typeof h))throw new p("Cannot perform operation at the desired path","OPERATION_PATH_UNRESOLVABLE",i,t,e)}}}function y(e,t,a,r=!0,n=!0){if(a&&!Array.isArray(t))throw new p("Patch sequence must be an array","SEQUENCE_NOT_AN_ARRAY");r||(e=l(e));const i=new Array(t.length);for(let r=0,s=t.length;r<s;r++)i[r]=b(e,t[r],a,!0,n,r),e=i[r].newDocument;return i.newDocument=e,i}function _(e,t,a){const r=b(e,t);if(!1===r.test)throw new p("Test operation failed","TEST_OPERATION_FAILED",a,t,e);return r.newDocument}function v(e,t,a,r){if("object"!=typeof e||null===e||Array.isArray(e))throw new p("Operation is not an object","OPERATION_NOT_AN_OBJECT",t,e,a);if(!f[e.op])throw new p("Operation `op` property is not one of operations defined in RFC-6902","OPERATION_OP_INVALID",t,e,a);if("string"!=typeof e.path)throw new p("Operation `path` property is not a string","OPERATION_PATH_INVALID",t,e,a);if(0!==e.path.indexOf("/")&&e.path.length>0)throw new p('Operation `path` property must start with "/"',"OPERATION_PATH_INVALID",t,e,a);if(("move"===e.op||"copy"===e.op)&&"string"!=typeof e.from)throw new p("Operation `from` property is not present (applicable in `move` and `copy` operations)","OPERATION_FROM_REQUIRED",t,e,a);if(("add"===e.op||"replace"===e.op||"test"===e.op)&&void 0===e.value)throw new p("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_REQUIRED",t,e,a);if(("add"===e.op||"replace"===e.op||"test"===e.op)&&d(e.value))throw new p("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED",t,e,a);if(a)if("add"==e.op){var n=e.path.split("/").length,i=r.split("/").length;if(n!==i+1&&n!==i)throw new p("Cannot perform an `add` operation at the desired path","OPERATION_PATH_CANNOT_ADD",t,e,a)}else if("replace"===e.op||"remove"===e.op||"_get"===e.op){if(e.path!==r)throw new p("Cannot perform the operation at a path that does not exist","OPERATION_PATH_UNRESOLVABLE",t,e,a)}else if("move"===e.op||"copy"===e.op){var s=E([{op:"_get",path:e.from,value:void 0}],a);if(s&&"OPERATION_PATH_UNRESOLVABLE"===s.name)throw new p("Cannot perform the operation from a path that does not exist","OPERATION_FROM_UNRESOLVABLE",t,e,a)}}function E(e,t,a){try{if(!Array.isArray(e))throw new p("Patch sequence must be an array","SEQUENCE_NOT_AN_ARRAY");if(t)y(l(t),l(e),a||!0);else{a=a||v;for(var r=0;r<e.length;r++)a(e[r],r,t,void 0)}}catch(e){if(e instanceof p)return e;throw e}}function O(e,t){if(e===t)return!0;if(e&&t&&"object"==typeof e&&"object"==typeof t){var a,r,n,i=Array.isArray(e),s=Array.isArray(t);if(i&&s){if((r=e.length)!=t.length)return!1;for(a=r;0!=a--;)if(!O(e[a],t[a]))return!1;return!0}if(i!=s)return!1;var o=Object.keys(e);if((r=o.length)!==Object.keys(t).length)return!1;for(a=r;0!=a--;)if(!t.hasOwnProperty(o[a]))return!1;for(a=r;0!=a--;)if(!O(e[n=o[a]],t[n]))return!1;return!0}return e!=e&&t!=t}new WeakMap;var T=a(13803);class S extends ReadableStream{constructor(){super(...arguments),Object.defineProperty(this,"reader",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}ensureReader(){this.reader||(this.reader=this.getReader())}async next(){this.ensureReader();try{const e=await this.reader.read();return e.done&&this.reader.releaseLock(),{done:e.done,value:e.value}}catch(e){throw this.reader.releaseLock(),e}}async return(){this.ensureReader();const e=this.reader.cancel();return this.reader.releaseLock(),await e,{done:!0,value:void 0}}[Symbol.asyncIterator](){return this}static fromReadableStream(e){const t=e.getReader();return new S({start:e=>function a(){return t.read().then((({done:t,value:r})=>{if(!t)return e.enqueue(r),a();e.close()}))}(),cancel(){t.releaseLock()}})}static fromAsyncGenerator(e){return new S({async pull(t){const{value:a,done:r}=await e.next();r&&t.close(),t.enqueue(a)}})}}class P{constructor(e){Object.defineProperty(this,"ops",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.ops=e.ops}concat(e){const t=this.ops.concat(e.ops),a=y({},t);return new A({ops:t,state:a[a.length-1].newDocument})}}class A extends P{constructor(e){super(e),Object.defineProperty(this,"state",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.state=e.state}concat(e){const t=this.ops.concat(e.ops),a=y(this.state,e.ops);return new A({ops:t,state:a[a.length-1].newDocument})}}class j extends T.Z{constructor(e){super(e),Object.defineProperty(this,"autoClose",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"includeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"keyMapByRunId",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"counterMapByRunName",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"transformStream",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"writer",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"receiveStream",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"log_stream_tracer"}),this.autoClose=e?.autoClose??!0,this.includeNames=e?.includeNames,this.includeTypes=e?.includeTypes,this.includeTags=e?.includeTags,this.excludeNames=e?.excludeNames,this.excludeTypes=e?.excludeTypes,this.excludeTags=e?.excludeTags,this.transformStream=new TransformStream,this.writer=this.transformStream.writable.getWriter(),this.receiveStream=S.fromReadableStream(this.transformStream.readable)}[Symbol.asyncIterator](){return this.receiveStream}async persistRun(e){}_includeRun(e){if(void 0===e.parent_run_id)return!1;const t=e.tags??[];let a=void 0===this.includeNames&&void 0===this.includeTags&&void 0===this.includeTypes;return void 0!==this.includeNames&&(a=a||this.includeNames.includes(e.name)),void 0!==this.includeTypes&&(a=a||this.includeTypes.includes(e.run_type)),void 0!==this.includeTags&&(a=a||void 0!==t.find((e=>this.includeTags?.includes(e)))),void 0!==this.excludeNames&&(a=a&&!this.excludeNames.includes(e.name)),void 0!==this.excludeTypes&&(a=a&&!this.excludeTypes.includes(e.run_type)),void 0!==this.excludeTags&&(a=a&&t.every((e=>!this.excludeTags?.includes(e)))),a}async onRunCreate(e){if(void 0===e.parent_run_id&&await this.writer.write(new P({ops:[{op:"replace",path:"",value:{id:e.id,streamed_output:[],final_output:void 0,logs:{}}}]})),!this._includeRun(e))return;void 0===this.counterMapByRunName[e.name]&&(this.counterMapByRunName[e.name]=0),this.counterMapByRunName[e.name]+=1;const t=this.counterMapByRunName[e.name];this.keyMapByRunId[e.id]=1===t?e.name:`${e.name}:${t}`;const a={id:e.id,name:e.name,type:e.run_type,tags:e.tags??[],metadata:e.extra?.metadata??{},start_time:new Date(e.start_time).toISOString(),streamed_output_str:[],final_output:void 0,end_time:void 0};await this.writer.write(new P({ops:[{op:"add",path:`/logs/${this.keyMapByRunId[e.id]}`,value:a}]}))}async onRunUpdate(e){try{const t=this.keyMapByRunId[e.id];if(void 0===t)return;const a=[{op:"add",path:`/logs/${t}/final_output`,value:e.outputs}];void 0!==e.end_time&&a.push({op:"add",path:`/logs/${t}/end_time`,value:new Date(e.end_time).toISOString()});const r=new P({ops:a});await this.writer.write(r)}finally{if(void 0===e.parent_run_id){const t=new P({ops:[{op:"replace",path:"/final_output",value:e.outputs}]});await this.writer.write(t),this.autoClose&&await this.writer.close()}}}async onLLMNewToken(e,t){const a=this.keyMapByRunId[e.id];if(void 0===a)return;const r=new P({ops:[{op:"add",path:`/logs/${a}/streamed_output_str/-`,value:t}]});await this.writer.write(r)}}var I=a(32385);async function x(e){return i.Ye.configure(e?.callbacks,void 0,e?.tags,void 0,e?.metadata)}var R=a(30803);function C(e,t){return e&&!Array.isArray(e)&&"object"==typeof e?e:{[t]:e}}class N extends I.i{constructor(){super(...arguments),Object.defineProperty(this,"lc_runnable",{enumerable:!0,configurable:!0,writable:!0,value:!0})}bind(e){return new $({bound:this,kwargs:e,config:{}})}map(){return new k({bound:this})}withRetry(e){return new M({bound:this,kwargs:{},config:{},maxAttemptNumber:e?.stopAfterAttempt,...e})}withConfig(e){return new $({bound:this,config:e,kwargs:{}})}withFallbacks(e){return new U({runnable:this,fallbacks:e.fallbacks})}_getOptionsList(e,t=0){if(Array.isArray(e)){if(e.length!==t)throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${e.length} options for ${t} inputs`);return e}return Array.from({length:t},(()=>e))}async batch(e,t,a){const r=this._getOptionsList(t??{},e.length),n=new R.L({maxConcurrency:a?.maxConcurrency,onFailedAttempt:e=>{throw e}}),i=e.map(((e,t)=>n.call((async()=>{try{return await this.invoke(e,r[t])}catch(e){if(a?.returnExceptions)return e;throw e}}))));return Promise.all(i)}async*_streamIterator(e,t){yield this.invoke(e,t)}async stream(e,t){return S.fromAsyncGenerator(this._streamIterator(e,t))}_separateRunnableConfigFromCallOptions(e={}){const t={callbacks:e.callbacks,tags:e.tags,metadata:e.metadata,runName:e.runName},a={...e};return delete a.callbacks,delete a.tags,delete a.metadata,delete a.runName,[t,a]}async _callWithConfig(e,t,a){const r=await x(a),n=await(r?.handleChainStart(this.toJSON(),C(t,"input"),void 0,a?.runType,void 0,void 0,a?.runName));let i;try{i=await e.bind(this)(t,a,n)}catch(e){throw await(n?.handleChainError(e)),e}return await(n?.handleChainEnd(C(i,"output"))),i}async _batchWithConfig(e,t,a,r){const n=this._getOptionsList(a??{},t.length),i=await Promise.all(n.map(x)),s=await Promise.all(i.map(((e,a)=>e?.handleChainStart(this.toJSON(),C(t[a],"input"),void 0,n[a].runType,void 0,void 0,n[a].runName))));let o;try{o=await e(t,n,s,r)}catch(e){throw await Promise.all(s.map((t=>t?.handleChainError(e)))),e}return await Promise.all(s.map((e=>e?.handleChainEnd(C(o,"output"))))),o}async*_transformStreamWithConfig(e,t,a){let r,n,i=!0,s=!0;const o=await x(a);let l;const c=this.toJSON(),d=async function*(){for await(const t of e){if(l||(l=await(o?.handleChainStart(c,{input:""},void 0,a?.runType,void 0,void 0,a?.runName))),i)if(void 0===r)r=t;else try{r=r.concat(t)}catch{r=void 0,i=!1}yield t}}();try{const e=t(d,l,a);for await(const t of e)if(yield t,s)if(void 0===n)n=t;else try{n=n.concat(t)}catch{n=void 0,s=!1}}catch(e){throw await(l?.handleChainError(e,void 0,void 0,void 0,{inputs:C(r,"input")})),e}await(l?.handleChainEnd(n??{},void 0,void 0,void 0,{inputs:C(r,"input")}))}_patchConfig(e={},t=void 0){const a={...e};return void 0!==t?(delete a.runName,{...a,callbacks:t}):a}pipe(e){return new L({first:this,last:F(e)})}async*transform(e,t){let a;for await(const t of e)a=void 0===a?t:a.concat(t);yield*this._streamIterator(a,t)}async*streamLog(e,t,a){const r=new j({...a,autoClose:!1}),n=t??{},{callbacks:i}=n;if(void 0===i)n.callbacks=[r];else if(Array.isArray(i))n.callbacks=i.concat([r]);else{const e=i.copy();e.inheritableHandlers.push(r),n.callbacks=e}const s=await this.stream(e,n),o=async function(){try{for await(const e of s){const t=new P({ops:[{op:"add",path:"/streamed_output/-",value:e}]});await r.writer.write(t)}}finally{await r.writer.close()}}();try{for await(const e of r)yield e}finally{await o}}static isRunnable(e){return!!e&&e.lc_runnable}}class $ extends N{static lc_name(){return"RunnableBinding"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","schema","runnable"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"bound",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.bound=e.bound,this.kwargs=e.kwargs,this.config=e.config}_mergeConfig(e){const t={...this.config};if(e)for(const a of Object.keys(e))t[a]="metadata"===a?{...t[a],...e[a]}:"tags"===a?(t[a]??[]).concat(e[a]??[]):e[a]??t[a];return t}bind(e){return this.constructor({bound:this.bound,kwargs:{...this.kwargs,...e},config:this.config})}withConfig(e){return this.constructor({bound:this.bound,kwargs:this.kwargs,config:{...this.config,...e}})}withRetry(e){return this.constructor({bound:this.bound.withRetry(e),kwargs:this.kwargs,config:this.config})}async invoke(e,t){return this.bound.invoke(e,this._mergeConfig({...t,...this.kwargs}))}async batch(e,t,a){const r=Array.isArray(t)?t.map((e=>this._mergeConfig({...e,...this.kwargs}))):this._mergeConfig({...t,...this.kwargs});return this.bound.batch(e,r,a)}async*_streamIterator(e,t){yield*this.bound._streamIterator(e,this._mergeConfig({...t,...this.kwargs}))}async stream(e,t){return this.bound.stream(e,this._mergeConfig({...t,...this.kwargs}))}async*transform(e,t){yield*this.bound.transform(e,this._mergeConfig({...t,...this.kwargs}))}static isRunnableBinding(e){return e.bound&&N.isRunnable(e.bound)}}class k extends N{static lc_name(){return"RunnableEach"}constructor(e){super(e),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","schema","runnable"]}),Object.defineProperty(this,"bound",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.bound=e.bound}bind(e){return new k({bound:this.bound.bind(e)})}async invoke(e,t){return this._callWithConfig(this._invoke,e,t)}async _invoke(e,t,a){return this.bound.batch(e,this._patchConfig(t,a?.getChild()))}}class M extends ${static lc_name(){return"RunnableRetry"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","schema","runnable"]}),Object.defineProperty(this,"maxAttemptNumber",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(this,"onFailedAttempt",{enumerable:!0,configurable:!0,writable:!0,value:()=>{}}),this.maxAttemptNumber=e.maxAttemptNumber??this.maxAttemptNumber,this.onFailedAttempt=e.onFailedAttempt??this.onFailedAttempt}_patchConfigForRetry(e,t,a){const r=e>1?`retry:attempt:${e}`:void 0;return this._patchConfig(t,a?.getChild(r))}async _invoke(e,t,a){return n((r=>super.invoke(e,this._patchConfigForRetry(r,t,a))),{onFailedAttempt:this.onFailedAttempt,retries:Math.max(this.maxAttemptNumber-1,0),randomize:!0})}async invoke(e,t){return this._callWithConfig(this._invoke,e,t)}async _batch(e,t,a,r){const i={};try{await n((async n=>{const s=e.map(((e,t)=>t)).filter((e=>void 0===i[e.toString()]||i[e.toString()]instanceof Error)),o=s.map((t=>e[t])),l=s.map((e=>this._patchConfigForRetry(n,t?.[e],a?.[e]))),c=await super.batch(o,l,{...r,returnExceptions:!0});let d;for(let e=0;e<c.length;e+=1){const t=c[e],a=s[e];t instanceof Error&&void 0===d&&(d=t),i[a.toString()]=t}if(d)throw d;return c}),{onFailedAttempt:this.onFailedAttempt,retries:Math.max(this.maxAttemptNumber-1,0),randomize:!0})}catch(e){if(!0!==r?.returnExceptions)throw e}return Object.keys(i).sort(((e,t)=>parseInt(e,10)-parseInt(t,10))).map((e=>i[parseInt(e,10)]))}async batch(e,t,a){return this._batchWithConfig(this._batch.bind(this),e,t,a)}}class L extends N{static lc_name(){return"RunnableSequence"}constructor(e){super(e),Object.defineProperty(this,"first",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"middle",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"last",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","schema","runnable"]}),this.first=e.first,this.middle=e.middle??this.middle,this.last=e.last}get steps(){return[this.first,...this.middle,this.last]}async invoke(e,t){const a=await x(t),r=await(a?.handleChainStart(this.toJSON(),C(e,"input"),void 0,void 0,void 0,void 0,t?.runName));let n,i=e;try{const e=[this.first,...this.middle];for(let a=0;a<e.length;a+=1){const n=e[a];i=await n.invoke(i,this._patchConfig(t,r?.getChild(`seq:step:${a+1}`)))}n=await this.last.invoke(i,this._patchConfig(t,r?.getChild(`seq:step:${this.steps.length}`)))}catch(e){throw await(r?.handleChainError(e)),e}return await(r?.handleChainEnd(C(n,"output"))),n}async batch(e,t,a){const r=this._getOptionsList(t??{},e.length),n=await Promise.all(r.map(x)),i=await Promise.all(n.map(((t,a)=>t?.handleChainStart(this.toJSON(),C(e[a],"input"),void 0,void 0,void 0,void 0,r[a].runName))));let s,o=e;try{const e=[this.first,...this.middle];for(let t=0;t<e.length;t+=1){const n=e[t];o=await n.batch(o,i.map(((e,a)=>this._patchConfig(r[a],e?.getChild(`seq:step:${t+1}`)))),a)}s=await this.last.batch(o,i.map((e=>this._patchConfig(r[this.steps.length-1],e?.getChild(`seq:step:${this.steps.length}`)))),a)}catch(e){throw await Promise.all(i.map((t=>t?.handleChainError(e)))),e}return await Promise.all(i.map(((e,t)=>e?.handleChainEnd(C(s[t],"output"))))),s}async*_streamIterator(e,t){const a=await x(t),r=await(a?.handleChainStart(this.toJSON(),C(e,"input"),void 0,void 0,void 0,void 0,t?.runName));let n=e;const i=[this.first,...this.middle,this.last],s=Math.min(i.length-1,i.length-[...i].reverse().findIndex((e=>{const t=e.transform===N.prototype.transform,a=$.isRunnableBinding(e)&&e.bound?.transform===N.prototype.transform;return t||a}))-1);try{const e=i.slice(0,s);for(let a=0;a<e.length;a+=1){const i=e[a];n=await i.invoke(n,this._patchConfig(t,r?.getChild(`seq:step:${a+1}`)))}}catch(e){throw await(r?.handleChainError(e)),e}let o,l=!0;try{let e=await i[s]._streamIterator(n,this._patchConfig(t,r?.getChild(`seq:step:${s+1}`)));const a=i.slice(s+1);for(let n=0;n<a.length;n+=1){const i=a[n];e=await i.transform(e,this._patchConfig(t,r?.getChild(`seq:step:${s+n+2}`)))}for await(const t of e)if(yield t,l)if(void 0===o)o=t;else try{o=o.concat(t)}catch(e){o=void 0,l=!1}}catch(e){throw await(r?.handleChainError(e)),e}await(r?.handleChainEnd(C(o,"output")))}pipe(e){return L.isRunnableSequence(e)?new L({first:this.first,middle:this.middle.concat([this.last,e.first,...e.middle]),last:e.last}):new L({first:this.first,middle:[...this.middle,this.last],last:F(e)})}static isRunnableSequence(e){return Array.isArray(e.middle)&&N.isRunnable(e)}static from([e,...t]){return new L({first:F(e),middle:t.slice(0,-1).map(F),last:F(t[t.length-1])})}}class D extends N{static lc_name(){return"RunnableMap"}getStepsKeys(){return Object.keys(this.steps)}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","schema","runnable"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"steps",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.steps={};for(const[t,a]of Object.entries(e.steps))this.steps[t]=F(a)}static from(e){return new D({steps:e})}async invoke(e,t){const a=await x(t),r=await(a?.handleChainStart(this.toJSON(),{input:e},void 0,void 0,void 0,void 0,t?.runName)),n={};try{await Promise.all(Object.entries(this.steps).map((async([a,i])=>{n[a]=await i.invoke(e,this._patchConfig(t,r?.getChild(a)))})))}catch(e){throw await(r?.handleChainError(e)),e}return await(r?.handleChainEnd(n)),n}}class H extends N{static lc_name(){return"RunnableLambda"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","schema","runnable"]}),Object.defineProperty(this,"func",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.func=e.func}static from(e){return new H({func:e})}async _invoke(e,t,a){let r=await this.func(e);return r&&N.isRunnable(r)&&(r=await r.invoke(e,this._patchConfig(t,a?.getChild()))),r}async invoke(e,t){return this._callWithConfig(this._invoke,e,t)}}class U extends N{static lc_name(){return"RunnableWithFallbacks"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","schema","runnable"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"runnable",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"fallbacks",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.runnable=e.runnable,this.fallbacks=e.fallbacks}*runnables(){yield this.runnable;for(const e of this.fallbacks)yield e}async invoke(e,t){const a=await i.Ye.configure(t?.callbacks,void 0,t?.tags,void 0,t?.metadata),r=await(a?.handleChainStart(this.toJSON(),C(e,"input"),void 0,void 0,void 0,void 0,t?.runName));let n;for(const a of this.runnables())try{const n=await a.invoke(e,this._patchConfig(t,r?.getChild()));return await(r?.handleChainEnd(C(n,"output"))),n}catch(e){void 0===n&&(n=e)}if(void 0===n)throw new Error("No error stored at end of fallback.");throw await(r?.handleChainError(n)),n}async batch(e,t,a){if(a?.returnExceptions)throw new Error("Not implemented.");const r=this._getOptionsList(t??{},e.length),n=await Promise.all(r.map((e=>i.Ye.configure(e?.callbacks,void 0,e?.tags,void 0,e?.metadata)))),s=await Promise.all(n.map(((t,a)=>t?.handleChainStart(this.toJSON(),C(e[a],"input"),void 0,void 0,void 0,void 0,r[a].runName))));let o;for(const t of this.runnables())try{const n=await t.batch(e,s.map(((e,t)=>this._patchConfig(r[t],e?.getChild()))),a);return await Promise.all(s.map(((e,t)=>e?.handleChainEnd(C(n[t],"output"))))),n}catch(e){void 0===o&&(o=e)}if(!o)throw new Error("No error stored at end of fallbacks.");throw await Promise.all(s.map((e=>e?.handleChainError(o)))),o}}function F(e){if("function"==typeof e)return new H({func:e});if(N.isRunnable(e))return e;if(Array.isArray(e)||"object"!=typeof e)throw new Error("Expected a Runnable, function or object.\nInstead got an unsupported type.");{const t={};for(const[a,r]of Object.entries(e))t[a]=F(r);return new D({steps:t})}}},30803:(e,t,a)=>{a.d(t,{L:()=>o});var r=a(42693),n=a(45860);const i=[400,401,402,403,404,405,406,407,408,409],s=e=>{if(e.message.startsWith("Cancel")||e.message.startsWith("TimeoutError")||"TimeoutError"===e.name||e.message.startsWith("AbortError")||"AbortError"===e.name)throw e;if("ECONNABORTED"===e?.code)throw e;const t=e?.response?.status??e?.status;if(t&&i.includes(+t))throw e;if("insufficient_quota"===e?.error?.code){const t=new Error(e?.message);throw t.name="InsufficientQuotaError",t}};class o{constructor(e){Object.defineProperty(this,"maxConcurrency",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxRetries",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"onFailedAttempt",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxConcurrency=e.maxConcurrency??1/0,this.maxRetries=e.maxRetries??6,this.onFailedAttempt=e.onFailedAttempt??s;const t=n.default;this.queue=new t({concurrency:this.maxConcurrency})}call(e,...t){return this.queue.add((()=>r((()=>e(...t).catch((e=>{throw e instanceof Error?e:new Error(e)}))),{onFailedAttempt:this.onFailedAttempt,retries:this.maxRetries,randomize:!0})),{throwOnTimeout:!0})}callWithOptions(e,t,...a){return e.signal?Promise.race([this.call(t,...a),new Promise(((t,a)=>{e.signal?.addEventListener("abort",(()=>{a(new Error("AbortError"))}))}))]):this.call(t,...a)}fetch(...e){return this.call((()=>fetch(...e).then((e=>e.ok?e:Promise.reject(e)))))}}},75606:(e,t,a)=>{a.d(t,{lS:()=>o,sA:()=>s});const r=()=>"undefined"!=typeof Deno,n=()=>{let e;return e="undefined"!=typeof window&&void 0!==window.document?"browser":"undefined"==typeof process||void 0===process.versions||void 0===process.versions.node||r()?"object"==typeof globalThis&&globalThis.constructor&&"DedicatedWorkerGlobalScope"===globalThis.constructor.name?"webworker":"undefined"!=typeof window&&"nodejs"===window.name||"undefined"!=typeof navigator&&(navigator.userAgent.includes("Node.js")||navigator.userAgent.includes("jsdom"))?"jsdom":r()?"deno":"other":"node",e};let i;async function s(){if(void 0===i){const e=n();i={library:"langchain-js",runtime:e}}return i}function o(e){try{return"undefined"!=typeof process?process.env?.[e]:void 0}catch(e){return}}}};